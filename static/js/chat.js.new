import { attachChatUI } from "./chat-ui-utils.js";
import { APP_CONFIG } from './appConfig.js'; // Import APP_CONFIG

/**
 * chat.js (Strict DI, Linted Edition)
 *
 * Usage:
 *   import { createChatManager } from './chat.js';
 *
 *   const chatManager = createChatManager({
 *     apiRequest,
 *     app,
 *     eventHandlers,
 *     modelConfig,
 *     projectDetailsComponent,
 *     isValidProjectId,
 *     isAuthenticated,
 *     domAPI,
 *     navAPI,
 *     DOMPurify,
 *   });
 *   await chatManager.initialize({ projectId: '123' });
 *   chatManager.cleanup();
 */

/**
 * @typedef {Object} DomAPI
 * @property {function(string): HTMLElement|null} querySelector
 * @property {function(string): HTMLElement|null} getElementById
 * @property {function(string): NodeListOf<HTMLElement>} querySelectorAll
 * @property {function(HTMLElement, HTMLElement): void} appendChild
 * @property {function(HTMLElement): HTMLElement[]} replaceChildren
 * @property {function(string): HTMLElement} createElement
 * @property {function(HTMLElement, string): void} removeChild
 * @property {function(HTMLElement, string): void} setInnerHTML
 */

/**
 * @typedef {Object} NavAPI
 * @property {function(): string} getSearch
 * @property {function(): string} getHref
 * @property {function(url: string): void} pushState
 * @property {function(): string} getPathname
 */

/**
 * @typedef {Object} EventHandlers
 * @property {function(HTMLElement, string, Function, Object=): any} trackListener
 * @property {function(HTMLElement, string, any): void} untrackListener
 */

/**
 * Default no-op DomAPI fallback if none provided.
 */
function createDefaultDomAPI() {
  throw new Error("[ChatManager] No domAPI provided. All DOM operations must be injected.");
}

/**
 * Default no-op NavAPI fallback if none provided.
 */
function createDefaultNavAPI() {
  throw new Error("[ChatManager] No navAPI provided. All navigation operations must be injected.");
}

/**
 * Default no-op eventHandlers if none provided.
 */
function createDefaultEventHandlers() {
  function trackListener() {
    throw new Error("[ChatManager] No eventHandlers.trackListener provided.");
  }
  function untrackListener() {
    throw new Error("[ChatManager] No eventHandlers.untrackListener provided.");
  }
  return { trackListener, untrackListener };
}

/**
 * Returns the injected modelConfig or a stub if unavailable.
 */
function getInjectedModelConfig(modelConfig) {
  if (modelConfig) return modelConfig;
  return {
    getConfig: () => ({}),
    updateConfig: () => { },
    getModelOptions: () => [],
    onConfigChange: () => { }
  };
}

/**
 * Defaults for chat if modelConfig is not provided or incomplete.
 */
const CHAT_CONFIG = {
  DEFAULT_MODEL: "claude-3-sonnet-20240229",
  MAX_TOKENS: 4096,
  THINKING_BUDGET: 16000,
  REASONING_EFFORT: "medium",
  MAX_IMAGE_SIZE: 4 * 1024 * 1024 // 4MB
};

/**
 * Simple queue to enforce sequential message sending.
 */
class MessageQueue {
  constructor() {
    this.queue = [];
    this.isProcessing = false;
  }

  add(task) {
    return new Promise((resolve) => {
      this.queue.push({ task, resolve });
      this.process();
    });
  }

  async process() {
    if (this.isProcessing || this.queue.length === 0) return;
    this.isProcessing = true;
    const { task, resolve } = this.queue.shift();
    try {
      const result = await task();
      resolve(result);
    } finally {
      this.isProcessing = false;
      this.process();
    }
  }
}

/**
 * Factory function for the ChatManager, with Strict DI approach.
 * @param {Object} options
 * @param {Function} options.apiRequest - Required (async for HTTP requests).
 * @param {Object} options.app - Required (has showNotification, etc.).
 * @param {EventHandlers} [options.eventHandlers] - For event tracking/untracking.
 * @param {Object} [options.modelConfig] - Model config manager with getConfig, updateConfig, etc.
 * @param {Object} [options.projectDetailsComponent] - Optional for broader UI integration (enable/disable chat).
 * @param {Function} options.isValidProjectId - Required ID validator.
 * @param {Function} options.isAuthenticated - Required auth checker.
 * @param {DomAPI} [options.domAPI] - DOM abstraction. No direct document usage.
 * @param {NavAPI} [options.navAPI] - Navigation / history abstraction. No direct window usage.
 * @param {Object} [options.DOMPurify] - Must be provided.
 * @param {Object} [options.apiEndpoints] - Required API endpoints.
 * @returns {ChatManager} An instance with initialize, sendMessage, etc.
 */
export function createChatManager({
  apiRequest,
  app,
  eventHandlers,
  modelConfig,
  projectDetailsComponent,
  isValidProjectId,
  isAuthenticated,
  domAPI,
  navAPI,
  DOMPurify,
  apiEndpoints
} = {}) {
  // Validate critical dependencies
  if (!domAPI || typeof domAPI.getDocument !== 'function') {
    // Allow domAPI to be initially undefined if chat is initialized headless or UI is deferred
  }
  if (!apiRequest) throw new Error('[ChatManager Factory] apiRequest is required.');
  if (!app) throw new Error('[ChatManager Factory] app is required.');
  if (!isValidProjectId) throw new Error('[ChatManager Factory] isValidProjectId is required.');
  if (!isAuthenticated) throw new Error('[ChatManager Factory] isAuthenticated is required.');
  if (!DOMPurify) throw new Error('[ChatManager Factory] DOMPurify is required.');
  if (!apiEndpoints) throw new Error('[ChatManager Factory] apiEndpoints is required.');

  // DependencySystem is crucial for waitFor
  const DependencySystem = app.DependencySystem; // Assuming app has DependencySystem
  if (!DependencySystem) throw new Error('[ChatManager Factory] DependencySystem is required (via app).');

  // Basic validation
  // Provide fallback DOM, Nav, and event handlers if not supplied
  const _domAPI = domAPI;
  const _navAPI = navAPI;
  const _EH = eventHandlers;

  /**
   * The main ChatManager class, constructed with all DI references enclosed.
   */
  class ChatManager {
    _api(endpoint, opts = {}) {
      return this.apiRequest(endpoint, opts);
    }

    constructor() {
      this.apiRequest = apiRequest;
      this.app = app;
      this.modelConfigAPI = getInjectedModelConfig(modelConfig);
      this.domAPI = _domAPI;
      this.navAPI = _navAPI;
      this.eventHandlers = _EH;
      this.projectDetails = projectDetailsComponent;
      this.isValidProjectId = isValidProjectId;
      this.isAuthenticated = isAuthenticated;
      this.DOMPurify = DOMPurify;

      this.projectId = null;
      this.currentConversationId = null;
      this.isInitialized = false;
      this.isLoading = false;
      this.isGlobalMode = false;
      this.currentImage = null;
      this.loadPromise = null;
      this.currentRequestId = 0;
      this.messageQueue = new MessageQueue();

      // UI references
      this.container = null;
      this.messageContainer = null;
      this.inputField = null;
      this.sendButton = null;
      this.titleElement = null;
      this.containerSelector = null; // For storing selector from init options
      this.messageContainerSelector = null;
      this.inputSelector = null;
      this.sendButtonSelector = null;
      this.minimizeButtonSelector = null;
      this._authChangeListener = null; // To store the auth listener for cleanup

      // Local copy of the model config
      this.modelConfig = this.modelConfigAPI.getConfig();
      this.DependencySystem = DependencySystem; // Store DependencySystem

      attachChatUI(this, {
        domAPI: this.domAPI,
        DOMPurify: this.DOMPurify,
        eventHandlers: this.eventHandlers
      });
    }

    /**
     * Initialize the chat manager with optional UI selectors or overrides.
     * @param {Object} [options={}]
     * @param {string} [options.projectId]
     * @param {string} [options.containerSelector]
     * @param {string} [options.messageContainerSelector]
     * @param {string} [options.inputSelector]
     * @param {string} [options.sendButtonSelector]
     * @param {string} [options.titleSelector] // titleSelector is still used for chat title
     * @param {string} [options.minimizeButtonSelector]
     */
    async initialize(options = {}) {
      const _initStart = performance.now();

      // Guardrail #10 â€“ wait until the core app (and DOM helpers) are ready
      await this.DependencySystem.waitFor?.(['app', 'domAPI', 'eventHandlers']);

      // Store selectors from options
      this.containerSelector = options.containerSelector || "#chatUI"; // Default if not provided
      this.messageContainerSelector = options.messageContainerSelector || "#conversationArea";
      this.inputSelector = options.inputSelector || "#chatInput";
      this.sendButtonSelector = options.sendButtonSelector || "#sendBtn";
      this.titleSelector = options.titleSelector || "#chatTitle"; // Keep titleSelector
      this.minimizeButtonSelector = options.minimizeButtonSelector || "#minimizeChatBtn";

      try {
        // Wait for auth module to be ready
        await this.DependencySystem.waitFor(['auth']);
        const auth = this.DependencySystem.modules.get('auth');

        if (!auth || !auth.isAuthenticated()) {
          const msg = "User not authenticated. Cannot initialize ChatManager.";
          this._handleError("initialization - not authenticated", msg);
          this.projectDetails?.disableChatUI?.("Not authenticated");

          // Listen for auth state changes to retry initialization
          if (!this._authChangeListener && auth?.AuthBus) {
            this._authChangeListener = async (e) => {
              if (e.detail?.authenticated && this.projectId) { // Check if projectId is set
                // Ensure eventHandlers is available before tracking
                if (this.eventHandlers && typeof this.eventHandlers.cleanupListeners === 'function') {
                    this.eventHandlers.cleanupListeners({ context: 'chatManagerAuthRetryListener' });
                }
                if (this._authChangeListener && auth?.AuthBus?.removeEventListener) {
                    auth.AuthBus.removeEventListener('authStateChanged', this._authChangeListener);
                }
                this._authChangeListener = null; // Clear listener after use
                await this.initialize({ // Pass original or current options
                    projectId: this.projectId, // Use the currently set projectId
                    containerSelector: this.containerSelector,
                    messageContainerSelector: this.messageContainerSelector,
                    inputSelector: this.inputSelector,
                    sendButtonSelector: this.sendButtonSelector,
                    titleSelector: this.titleSelector,
                    minimizeButtonSelector: this.minimizeButtonSelector
                });
              }
            };
            // Ensure eventHandlers is available before tracking
            if (this.eventHandlers && typeof this.eventHandlers.trackListener === 'function') {
                this.eventHandlers.trackListener(auth.AuthBus, 'authStateChanged', this._authChangeListener, {
                    context: 'chatManagerAuthRetryListener', // Unique context for this listener
                    description: 'Auth state change listener for chat initialization retry'
                });
            } else {
                auth?.AuthBus?.addEventListener('authStateChanged', this._authChangeListener);
            }
          }
          throw new Error(msg); // Propagate error to stop further execution in this attempt
        }

        // If already initialized for the same project, re-bind UI if selectors changed, otherwise skip.
        const requestedProjectId = options.projectId && this.isValidProjectId(options.projectId)
          ? options.projectId
          : this.projectId; // Fallback to current if options.projectId is not valid

        if (this.isInitialized && this.projectId === requestedProjectId) {
          await this._setupUIElements(); // Use stored selectors
          this._setupEventListeners();   // Use stored selectors
          return true;
        }

        // Store projectId if provided and valid
        if (options.projectId && this.isValidProjectId(options.projectId)) {
            this.projectId = options.projectId;
        } else if (!this.projectId && requestedProjectId) { // If this.projectId isn't set, use requested if valid
            this.projectId = requestedProjectId;
        }

        if (!this.projectId) {
            const noProjectMsg = "No valid project ID provided for ChatManager initialization.";
            throw new Error(noProjectMsg);
        }

        this.isGlobalMode = !this.isValidProjectId(this.projectId); // Recalculate global mode

        // If switching projects, reset relevant state
        if (this.isInitialized && this.projectId !== requestedProjectId) {
            this.currentConversationId = null;
            this.loadPromise = null;
            this.isLoading = false;
            if(this.messageContainer) this._clearMessages(); // Clear messages only if UI is set up
        }
        this.projectId = requestedProjectId; // Update to the new project ID

        await this._setupUIElements(); // Uses stored selectors
        this._setupEventListeners();   // Uses stored selectors

        const newConversationBtn = this.domAPI.getElementById("newConversationBtn");
        if (newConversationBtn) {
            newConversationBtn.classList.remove("hidden");
            if (typeof this.eventHandlers.cleanupListeners === 'function') {
                this.eventHandlers.cleanupListeners({ context: 'chatManager:newConvoBtn' });
            }
            this.eventHandlers.trackListener(
                newConversationBtn,
                "click",
                async () => {
                    try {
                        await this.createNewConversation();
                    } catch (err) {
                        this._handleError("New Conversation Button", err);
                        this._showErrorMessage("Failed to start new chat: " + (err?.message || err));
                    }
                },
                { description: "New Conversation Button", context: "chatManager:newConvoBtn", source: "ChatManager.initialize" }
            );
        }

        if (this.isGlobalMode) {
            if(this.messageContainer) this._clearMessages();
            if(this.messageContainer) this._showMessage("system", "Select a project or start a new global chat.");
            this.isInitialized = true;
            return true;
        }

        // Load conversation history or start new one
        await this._loadConversationHistory(); // This will also handle URL params for chatId

        this.isInitialized = true;
        return true;

      } catch (error) {
        // Error already logged by specific failure points or _handleError
        this.isInitialized = false; // Ensure state reflects failure

        // Check for specific "Project has no knowledge base" error to provide better feedback
        const originalErrorMessage = this._extractErrorMessage(error.originalError || error);
        if (originalErrorMessage.includes("Project has no knowledge base")) {
          const specificMessage = "Chat initialization failed: Project has no knowledge base. Please add one to enable chat.";
          this._showErrorMessage(specificMessage); // Show in chat UI
          this.projectDetails?.disableChatUI?.(specificMessage); // Update project details component
        }
        return false; // Indicate failure
      }
    }

    /**
     * Cleanup method to remove all tracked event listeners, etc.
     */
    cleanup() {
      // Remove all tracked listeners for this ChatManager instance
      if (typeof this.eventHandlers.cleanupListeners === 'function') {
        this.eventHandlers.cleanupListeners({ context: 'chatManager' });
      }
      this.isInitialized = false;
      this.currentConversationId = null;
      this.projectId = null;
      this.isGlobalMode = false;
      this._clearMessages();
    }

    /**
     * Loads an existing conversation by ID.
     * @param {string} conversationId
     */
    async loadConversation(conversationId) {
      if (!conversationId) {
        return false;
      }
      if (!this.isAuthenticated()) {
        return false;
      }
      if (!this.isValidProjectId(this.projectId)) {
        const errorMsg = `Invalid or missing project ID (${this.projectId}). Cannot load conversation.`;
        this._handleError("loading conversation", errorMsg);
        this._showErrorMessage("Cannot load conversation: invalid/missing project ID.");
        return false;
      }

      const requestId = ++this.currentRequestId;
      if (this.loadPromise) {
        const result = await this.loadPromise;
        return requestId === this.currentRequestId ? result : false;
      }

      this.isLoading = true;
      this._showLoadingIndicator();

      this.loadPromise = (async () => {
        try {
          this._clearMessages();

          // Parallel fetch conversation + messages
          const [conversationResponse, messagesResponse] = await Promise.all([
            this._api(apiEndpoints.CONVERSATION(this.projectId, conversationId), { method: "GET" }),
            this._api(apiEndpoints.MESSAGES(this.projectId, conversationId), { method: "GET" })
          ]);

          const conversation =
                conversationResponse?.data?.conversation
             ?? conversationResponse?.data
             ?? conversationResponse?.conversation
             ?? conversationResponse;

          if (!conversation?.id) {
            throw new Error('Failed to fetch valid conversation details.');
          }

          const messages = messagesResponse.data?.messages || [];

          this.currentConversationId = conversationId;
          if (this.titleElement) {
            this.titleElement.textContent = conversation.title || "New Conversation";
          }
          this._renderMessages(messages);
          this._updateURLWithConversationId(conversationId);

          return true;
        } catch (error) {
          this._handleError("loading conversation", error);
          return false;
        } finally {
          this.isLoading = false;
          this._hideLoadingIndicator();
          this.loadPromise = null;
        }
      })();

      return this.loadPromise;
    }

    /**
     * Creates a new conversation on the server for the current project.
     * @param {string} [overrideProjectId]
     */
    async createNewConversation(overrideProjectId) {
      if (overrideProjectId) {
        this.projectId = this.isValidProjectId(overrideProjectId) ? overrideProjectId : this.projectId;
      }

      if (!this.isAuthenticated()) {
        throw new Error("Not authenticated");
      }
      if (!this.isValidProjectId(this.projectId)) {
        const errorMsg = `Invalid or missing project ID (${this.projectId}). Cannot create new conversation.`;
        this._showErrorMessage(errorMsg);
        this._handleError("creating new conversation", errorMsg);
        this.projectDetails?.disableChatUI?.("No valid project");
        throw new Error(errorMsg);
      }

      this._clearMessages();

      try {
        const cfg = this.modelConfigAPI.getConfig();
        const currentUser = this.app?.state?.currentUser || {};

        /* If the user record hasn't loaded yet but we are already
           authenticated, proceed and let the backend infer the user
           from the auth token. */
        const payload = {
          title: `New Chat ${new Date().toLocaleString()}`,
          model_id: cfg.modelName || CHAT_CONFIG.DEFAULT_MODEL
        };
        if (currentUser.id) payload.user_id = currentUser.id;

        const convoEndpoint = typeof apiEndpoints.CONVERSATIONS === 'function'
          ? apiEndpoints.CONVERSATIONS(this.projectId)
          : String(apiEndpoints.CONVERSATIONS).replace('{id}', this.projectId);

        const response = await this._api(convoEndpoint, { method: "POST", body: payload });

        const conversation =
              response?.data?.conversation
           ?? response?.data
           ?? response?.conversation
           ?? response;

        if (!conversation?.id) {
          throw new Error('Server response missing conversation ID');
        }

        this.currentConversationId = conversation.id;
        if (this.titleElement) {
          this.titleElement.textContent = conversation.title || "New Conversation";
        }
        this._updateURLWithConversationId(conversation.id);

        // Dispatch event for sidebar or other components to update
        const doc = this.domAPI.getDocument();
        if (doc && typeof doc.dispatchEvent === 'function') {
            const event = new CustomEvent('chat:conversationCreated', {
                detail: {
                    conversationId: conversation.id,
                    projectId: this.projectId,
                    title: conversation.title
                }
            });
            doc.dispatchEvent(event);
        }

        return conversation;
      } catch (error) {
        const errorMessage = this._extractErrorMessage(error);
        this._handleError("creating new conversation", error);

        if (errorMessage.includes("Project has no knowledge base")) {
          const specificMessage = "Project has no knowledge base. Please add one to enable chat.";
          this._showErrorMessage(specificMessage);
          this.projectDetails?.disableChatUI?.(specificMessage);
        } else {
          this._showErrorMessage("Failed to create conversation: " + errorMessage);
          this.projectDetails?.disableChatUI?.("Chat error: " + errorMessage);
        }
        throw error; // This re-throws the error
      }
    }

    /**
     * Sends a user message (queued) and awaits assistant reply.
     * @param {string} messageText
     */
    async sendMessage(messageText) {
      if (!messageText?.trim()) {
        return;
      }

      return this.messageQueue.add(async () => {
        if (!this.isAuthenticated()) {
          return;
        }
        if (!this.isValidProjectId(this.projectId)) {
          const errorMsg = `No valid project ID (${this.projectId}). Select a project before sending messages.`;
          this._showErrorMessage(errorMsg);
          this._handleError("sending message", errorMsg);
          this.projectDetails?.disableChatUI?.("No valid project");
          return;
        }
        if (!this.currentConversationId) {
          try {
            await this.createNewConversation();
            if (!this.currentConversationId) {
              return;
            }
          } catch (error) {
            return; // Stop if conversation creation failed
          }
        }

        // Show user message in UI
        this._showMessage("user", messageText);
        this._clearInputField();
        this._showThinkingIndicator();

        try {
          const response = await this._sendMessageToAPI(messageText);
          this._processAssistantResponse(response);
          return response.data;
        } catch (error) {
          this._hideThinkingIndicator();
          this._showErrorMessage(error.message);
          this._handleError("sending message", error);
          this.projectDetails?.disableChatUI?.("Chat error: " + (error.message || error));
        }
      });
    }

    /**
     * Internal method that calls the API for sending a user message.
     * @private
     * @param {string} messageText
     */
    async _sendMessageToAPI(messageText) {
      const cfg = this.modelConfigAPI.getConfig();
      const payload = {
        content: messageText,
        role: "user",
        type: "message",
        vision_detail: cfg.visionDetail || "auto"
      };
      if (this.currentImage) {
        this._validateImageSize();
        payload.image_data = this.currentImage;
        this.currentImage = null; // Clear after adding to payload
      }
      if (cfg.extendedThinking) {
        payload.thinking = {
          type: "enabled",
          budget_tokens: cfg.thinkingBudget
        };
      }
      return this._api(
        apiEndpoints.MESSAGES(this.projectId, this.currentConversationId),
        { method: "POST", body: payload }
      );
    }

    /**
     * Ensure the currently attached image is within size limits.
     * @private
     */
    _validateImageSize() {
      if (typeof this.currentImage === 'string' && this.currentImage.startsWith("data:")) {
        const commaIdx = this.currentImage.indexOf(',');
        const b64 = commaIdx !== -1 ? this.currentImage.slice(commaIdx + 1) : this.currentImage;
        const sizeBytes = Math.floor((b64.length * 3) / 4);
        if (sizeBytes > CHAT_CONFIG.MAX_IMAGE_SIZE) {
          this._hideThinkingIndicator();
          const errorMsg = `Image is too large (${(sizeBytes / (1024*1024)).toFixed(1)}MB). Max allowed: ${CHAT_CONFIG.MAX_IMAGE_SIZE / (1024*1024)}MB.`;
          throw new Error(errorMsg);
        }
      }
    }

    /**
     * Process the API's assistant response or show an error if missing.
     * @private
     * @param {Object} response
     */
    _processAssistantResponse(response) {
      this._hideThinkingIndicator();
      if (response.data?.assistant_message) {
        const { assistant_message, thinking, redacted_thinking } = response.data;
        this._showMessage(
          "assistant",
          assistant_message.content,
          null,
          thinking,
          redacted_thinking
        );
      } else if (response.data?.assistant_error) {
        const errMsg = this._extractErrorMessage(response.data.assistant_error);
        throw new Error(errMsg);
      }
    }

    /**
     * Deletes the current conversation (server-side).
     */
    async deleteConversation() {
      if (!this.currentConversationId) {
        return false;
      }
      if (!this.isAuthenticated()) {
        return false;
      }
      if (!this.isValidProjectId(this.projectId)) {
        const errorMsg = `Invalid or missing project ID (${this.projectId}). Cannot delete conversation.`;
        this._handleError("deleting conversation", errorMsg);
        this._showErrorMessage("Cannot delete conversation: invalid/missing project ID.");
        return false;
      }
      try {
        await this._api(
          apiEndpoints.CONVERSATION(this.projectId, this.currentConversationId),
          { method: "DELETE" }
        );
        this.currentConversationId = null;
        this._clearMessages();
        this._removeConversationIdFromURL();
        return true;
      } catch (error) {
        this._handleError("deleting conversation", error);
        return false;
      }
    }

    /**
     * For attaching an image to the next user message.
     * @param {string} base64Image
     */
    setImage(base64Image) {
      this.currentImage = base64Image;
    }

    /**
     * Update the model config and refresh internal config state.
     * @param {Object} config
     */
    updateModelConfig(config) {
      this.modelConfigAPI.updateConfig(config);
      this.modelConfig = this.modelConfigAPI.getConfig();
    }

    // -------------------- UI Methods ----------------------

    // UI methods moved to chat-ui-utils.js via attachChatUI
    async _loadConversationHistory() {
      if (!this.projectId) {
        if(this.messageContainer) this._showMessage("system", "Please select a project to start chatting.");
        return;
      }

      const urlParams = new URLSearchParams(this.navAPI.getSearch());
      const urlChatId = urlParams.get('chatId');

      if (urlChatId) {
        const loadedSuccessfully = await this.loadConversation(urlChatId);
        if (loadedSuccessfully) {
          return; // Specific conversation loaded
        }
        this._removeConversationIdFromURL(); // Remove invalid/failed chatId
      }

      // If no specific chat ID in URL, or if it failed to load, try to get latest or create new.
      try {
        // The _api method should already return the 'data' part of the response,
        // or the full JSON if it's not wrapped with {status: 'success', data: ...}
        const responseData = await this._api(apiEndpoints.CONVERSATIONS(this.projectId), { method: 'GET', params: { limit: 1, sort: 'desc' } });

        // Adapt to how _api returns data.
        // Common patterns: responseData.conversations, or responseData directly if it's an array.
        const conversations = responseData?.conversations || (Array.isArray(responseData) ? responseData : []);

        if (conversations && conversations.length > 0) {
          this.currentConversationId = conversations[0].id;
          if (this.titleElement) this.titleElement.textContent = conversations[0].title || "Conversation";
          await this._loadMessages(this.currentConversationId);
          this._updateURLWithConversationId(this.currentConversationId); // Update URL if we picked the latest
        } else {
          await this.createNewConversation(); // This will set currentConversationId and update URL
        }
      } catch (error) {
        await this.createNewConversation(); // Fallback to creating a new one on error
      }
    }

    async _loadMessages(conversationId) {
      if (!conversationId) {
        return;
      }
      if (!this.messageContainer) {
        return;
      }
      this._showLoadingIndicator(); // Show loading indicator for messages

      try {
        const response = await this._api(apiEndpoints.MESSAGES(this.projectId, conversationId), { method: 'GET' });
        const messages = response?.messages || response?.data?.messages || response || []; // Adapt to actual response structure

        this._clearMessages(); // Clear existing messages
        messages.forEach(message => {
          this._showMessage(message.role, message.content, message.id, message.thinking, message.redacted_thinking);
        });
        if (this.messageContainer) {
          this.messageContainer.scrollTop =

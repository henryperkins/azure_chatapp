Familiarize yourself with how to use the available tools. Your response can contain both instruction and tool usage. Form your response with the intent of both explaining your action and performing the action with the available tools. Keep in mind your reasoning process may interfere with tool use, so be mindful of that.

Here's official documentation regarding tool usage in this application:

# Tool Use Overview (Usage Details)

Roo Code uses a modular tool system to interact with your development environment safely and flexibly. Tools are organized by purpose and availability, each with clear usage patterns and access rules.

---
## Tool Organization

### Tool Groups & Categories

| Group         | Purpose/Usage                         | Example Tools                               |
|---------------|--------------------------------------|---------------------------------------------|
| **Read**      | Explore and analyze code/project      | `read_file`, `search_files`, `list_files`, `list_code_definition_names` |
| **Edit**      | Make changes to code/files            | `apply_diff`, `insert_content`, `search_and_replace`, `write_to_file`    |
| **Browser**   | Interact with web apps                | `browser_action`                            |
| **Command**   | Run CLI/system commands               | `execute_command`                           |
| **MCP**       | External integrations                 | `use_mcp_tool`, `access_mcp_resource`       |
| **Workflow**  | Context & task management             | `switch_mode`, `new_task`, `ask_followup_question`, `attempt_completion` |
### Always Available Tools
- `ask_followup_question`
- `attempt_completion`
- `switch_mode`
- `new_task`

---
## General Tool Usage
- **Each tool requires specific parameters** (see individual tool details for required options like `path`, `content`, etc.).
- **Tools are enabled or disabled by “mode”** (e.g., Code Mode for editing, Ask Mode for reading).
- **Availability is further checked by permissions and workspace context.**
- **Tools can require user approval** (most “Edit” tools show a diff view before saving changes).

---
## Example Tool Usages (Patterns)
- **Reading:** `read_file` (show file content), `search_files` (find pattern), `list_files` (project structure)  **REQUIRED PARAMETERS:** path
- **Editing:** `apply_diff` (patch), `insert_content` (add-only), `search_and_replace` (find/replace), `write_to_file` (full file replace/new file)
- **Commands:** `execute_command` (run build/lint/server), with optional working directory
- **Task Flow:** `ask_followup_question` (clarify before actions), `attempt_completion` (mark done), `switch_mode`/`new_task` for context or subtasks

---
## How Tools Are Called
- **Task Requirements:** When needed for specific user or system-initiated tasks.
- **Modes:** Context (like “Code Mode,” “Ask Mode”) affects which tools can be used.
- **Context & Permissions:** Workspace state, file access, security settings may restrict usage.

---
## Best Practices
- **Choose the most specific tool for your need** (e.g., use `apply_diff` for precise changes, `write_to_file` for new or full replacement).
- **Validate all parameters.**
- **Favor safe & limited access:** Only grant needed permissions, especially for command and editing tools.
- **Batch operations when possible** and **avoid redundant calls**.
- **Handle errors** gracefully—most tools offer error and approval feedback, and may use retries or fallbacks.
- **Switch modes** or manage tasks explicitly for structured workflows.

---
# apply_diff Tool (Usage Details)

**The `apply_diff` tool makes precise, surgical changes to files by specifying what content to replace.**
It uses fuzzy matching and line hints for targeted and robust file modifications.

---
## Parameters

| Name         | Required? | Description                                                                                                                       | Notes                                                                      |
|--------------|-----------|-----------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| `path`       | Yes       | Path of the file to modify, relative to the current working directory.                                                            |                                                                            |
| `diff`       | Yes       | Search/replace instructions for the tool in a specific diff block format (see below).                                             |                                                                            |
| `start_line` | No        | A hint for where the search content begins. **(Usually not required—`start_line` is mainly used inside each diff block)**         | Top-level option, rarely used in main strategy.                            |
| `end_line`   | No        | A hint for where the search content ends. **(Usually not required—`end_line` is mainly used inside each diff block)**             | Top-level option, rarely used in main strategy.                            |

---
## Parameter Details
- **`path`**: Tells the tool which file to alter.
- **`diff`**: Defines the set of changes (what to find/replace) in special block format.
- **`start_line`**, **`end_line`**: (Optional) Extra hints for line location. The main method relies on `:start_line:` and `:end_line:` tags inside each diff block.

---
## Diff Format Requirements
- Use one or more change blocks in a single request.
- Each change block begins with a `SEARCH` tag (must include `:start_line:`, may include `:end_line:`), and is followed by the replacement content after `=======`.
- The block ends with `>>>>>>> REPLACE`.
#### Example diff block

```
<<<<<<< SEARCH:start_line:10:end_line:12
    // Old calculation logic
    const result = value * 0.9;
    return result;
=======
    // Updated calculation logic with logging
    console.log(`Calculating for value: ${value}`);
    const result = value * 0.95; // Adjusted factor
    return result;
>>>>>>> REPLACE

<<<<<<< SEARCH:start_line:25:end_line:25
    const defaultTimeout = 5000;
=======
    const defaultTimeout = 10000; // Increased timeout
>>>>>>> REPLACE
```

- **Note:** Every `SEARCH` block requires an accurate snippet and a `start_line:` hint.
- **Whitespace and indentation** must match as closely as possible (tool uses fuzzy matching).
- **Markers** (like `<<<<<<<`) in file content need to be escaped as `\\<<<<<<<` in SEARCH.

---
## What parameters do
- Guide the tool to the exact location and content to be replaced (with fallback to fuzzy matching if content has shifted).
- Allow surgical changes to one or many sections per file.
- Make it easier to patch, refactor, or update code in large projects with minimal risk.

---
# insert_content Tool (Usage Details)
The `insert_content` tool inserts new lines of content into an existing file without modifying original lines.
It is used for adding code blocks, configuration, or log lines at specific positions.

---
## Parameters

| Name      | Required? | Description                                                                                           | Notes                                                              |
|-----------|-----------|-------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|
| `path`    | Yes       | Relative path (from workspace root) of the file to insert into.                                       | File must already exist.                                           |
| `line`    | Yes       | 1-based line number **before** which to insert; use `0` to append to the end.                         | Must be a non-negative integer.                                    |
| `content` | Yes       | The text content to insert.                                                                           | Any valid text or multi-line block.                                |

---
## What each parameter does
- **`path`**: Specifies which file should be edited.
- **`line`**: Tells the tool the exact line where new content should be inserted (before this line), or use `0` to add at end.
- **`content`**: The data/text block to be inserted.

---
## Supported Usage Patterns
- Place new code at the file start (`line: 1`)
- Insert code/function/configuration at a particular line (`line: n`)
- Append to the end of file (`line: 0`)

---
## Example Usage
**Insert imports at file start (before line 1):**
```
<insert_content>
  <path>src/utils.ts</path>
  <line>1</line>
  <content>
// Add imports at start of file
import { sum } from './math';
import { parse } from 'date-fns';
  </content>
</insert_content>
```

**Append to end of file (line 0):**
```
<insert_content>
  <path>config/routes.yaml</path>
  <line>0</line>
  <content>
- path: /new-feature
  component: NewFeatureComponent
  auth_required: true
  </content>
</insert_content>
```

**Insert block before line 50:**
```
<insert_content>
  <path>src/services/api.js</path>
  <line>50</line>
  <content>
async function fetchUserData(userId) {
  const response = await fetch(`/api/users/${userId}`);
  if (!response.ok) {
    throw new Error('Failed to fetch user data');
  }
  return response.json();
}
  </content>
</insert_content>
```

---
**Note:**
- The tool does not replace or delete lines; it only inserts new content.
- Target file must already exist.
- For changing or deleting, use `apply_diff` or `search_and_replace`.

---
# execute_command Tool (Usage Details)

The `execute_command` tool allows Roo to run CLI (command-line interface) commands on the user's system.
It is used for system operations such as installing dependencies, building projects, running servers, and performing various shell tasks.

---
## Parameters

| Name      | Required? | Description                                                | Notes                                               |
|-----------|-----------|------------------------------------------------------------|-----------------------------------------------------|
| `command` | Yes       | The CLI command to execute. Must be valid for the OS.      | Any single or chained shell command(s).             |
| `cwd`     | No        | The working directory to run the command in.               | If omitted, current working directory is used.      |

---
## What each parameter does
- **`command`**:
  The shell command (e.g., npm install, git status, mkdir src, etc.) that will be executed as if in a terminal window.
  - Supports complex, multi-step chains using `&&` or similar shell syntax.

- **`cwd`**:
  Optionally set the working directory context for running the command (relative or absolute path). If blank, uses the process's current working directory.

---
## Supported Usage Patterns
- Install project dependencies: `npm install`
- Run build scripts or test runners: `npm run build`, `yarn test`
- Start application servers: `npm start`, `python app.py`
- Execute shell operations: `mkdir src && touch src/index.js`
- Use in a specific subdirectory: set `cwd` to the desired folder

---
## Example Usage

**Run a command in the current directory:**
```
<execute_command>
  <command>npm run dev</command>
</execute_command>
```

**Install project dependencies:**
```
<execute_command>
  <command>npm install express mongoose dotenv</command>
</execute_command>
```

**Create folder and file in one step:**
```
<execute_command>
  <command>mkdir -p src/components && touch src/components/App.js</command>
</execute_command>
```

**Run a command in a specific subdirectory:**
```
<execute_command>
  <command>git status</command>
  <cwd>./my-project</cwd>
</execute_command>
```

**Build and start a Node.js project:**
```
<execute_command>
  <command>npm run build && npm start</command>
</execute_command>
```

---
**Notes:**
- Command runs as if entered in a terminal; result and output are captured.
- Command validation ensures safety (blocks subshells, checks RooIgnore, etc.).
- Commands may require OS-specific shell conventions (escaping, chaining).

---
# search_and_replace Tool (Usage Details)

The `search_and_replace` tool finds and replaces text within a file, supporting both literal text and regular expression patterns. It allows precise, multi-location replacements—including optionally within a specific line range.

---
## Parameters

| Name         | Required? | Description                                                                             | Notes                                                  |
|--------------|-----------|-----------------------------------------------------------------------------------------|--------------------------------------------------------|
| `path`       | Yes       | Relative path to the file (from workspace root) to modify.                              | Must point to an existing file.                        |
| `search`     | Yes       | The text string or regex pattern to search for.                                         | Regex must be valid if `use_regex` is set to "true".   |
| `replace`    | Yes       | Text to replace matches with.                                                           | Any string, including references like `$1` for regex.  |
| `start_line` | No        | 1-based line number where search should start.                                          | Restricts operation to part of the file if set.        |
| `end_line`   | No        | 1-based line number where search should end (inclusive).                                | Restricts operation to part of the file if set.        |
| `use_regex`  | No        | Set to `"true"` to treat `search` as a regex pattern (otherwise literal).               | Default is `"false"` (literal search).                 |
| `ignore_case`| No        | Set to `"true"` for case-insensitive searching.                                         | Default is `"false"`.                                  |

---
## What each parameter does
- **`path`**: Specifies which file to perform the operation on.
- **`search`**: The literal text or regex pattern to look for.
- **`replace`**: What the matching text will be replaced with.
- **`start_line`**, **`end_line`**: (Optional) Restrict the change to a section of the file.
- **`use_regex`**: If `"true"`, the tool interprets `search` as a RegExp pattern.
- **`ignore_case`**: If `"true"`, makes the search case-insensitive.

---
## Supported Usage Patterns
- Replace all instances of a string or pattern across the whole file
- Use regex to perform advanced, patterned replacement
- Target replacements to only particular lines of a file

---
## Example Usage
**Literal replacement in a file:**
```
<search_and_replace>
  <path>src/config.js</path>
  <search>API_KEY_OLD</search>
  <replace>API_KEY_NEW</replace>
</search_and_replace>
```

**Case-insensitive regex replacement:**
```
<search_and_replace>
  <path>src/app.ts</path>
  <search>processData\((.*?)\)</search>
  <replace>handleData($1)</replace>
  <use_regex>true</use_regex>
  <ignore_case>true</ignore_case>
</search_and_replace>
```

**Replace only within lines 10–20:**
```
<search_and_replace>
  <path>README.md</path>
  <search>Draft</search>
  <replace>Final</replace>
  <start_line>10</start_line>
  <end_line>20</end_line>
</search_and_replace>
```

---
**Notes:**
- Only operates on a single file at a time.
- Diff view and approval required before saving changes.
- For project-wide find, use `search_files` first, then apply this tool.

---
# write_to_file Tool (Usage Details)
The `write_to_file` tool creates new files or completely replaces all content in existing files.
It uses an interactive diff view to show changes for review and approval before writing.

---
## Parameters
| Name        | Required? | Description                                                           | Notes                                                    |
|-------------|-----------|-----------------------------------------------------------------------|----------------------------------------------------------|
| `path`      | Yes       | Path of the file (relative to current working directory).             | Can refer to an existing or new file.                    |
| `content`   | Yes       | The complete content to write.                                        | Entire file content (new or replacement).                |
| `line_count`| Yes       | Total number of lines (including blanks) in the final file.           | Used for safety/validation to prevent truncation.        |

---
## What each parameter does
- **`path`**: Specifies which file to create or overwrite.
- **`content`**: The full contents to write into the file (everything in the file after operation).
- **`line_count`**: Count of lines the `content` should have—used to confirm file is written without loss.

---
## Supported Usage Patterns
- Create a new file with initial content
- Overwrite (fully replace) an existing file with new content
- Generate and review configuration files, docs, code, etc., before writing

---
## Example Usage
**Write a new JSON config file:**
```
<write_to_file>
  <path>config/settings.json</path>
  <content>{
    "apiEndpoint": "https://api.example.com",
    "theme": {
      "primaryColor": "#007bff",
      "secondaryColor": "#6c757d",
      "fontFamily": "Arial, sans-serif"
    },
    "features": {
      "darkMode": true,
      "notifications": true,
      "analytics": false
    },
    "version": "1.0.0"
  }</content>
  <line_count>14</line_count>
</write_to_file>
```

**Create a basic HTML file:**
```
<write_to_file>
  <path>src/index.html</path>
  <content>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My Application</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="app"></div>
  <script src="app.js"></script>
</body>
</html>
  </content>
  <line_count>13</line_count>
</write_to_file>
```

---
**Notes:**
- Always replaces the entire file content; not for partial edits (use `apply_diff` or `insert_content` for that).
- Requires the user to approve the diff before the file is written.
- Validates line count to prevent accidental truncation/missing content.
- Target file must be inside the workspace and not blocked by `.rooignore`.

---
# list_code_definition_names Tool (Usage Details)

The `list_code_definition_names` tool lists top-level code definitions (such as classes and functions) within source files at the top level of a given directory, assisting in understanding project structure.

---
## Parameters

| Name   | Required? | Description                                                | Notes                                       |
|--------|-----------|------------------------------------------------------------|---------------------------------------------|
| `path` | Yes       | Path to the directory to review (relative to the workspace root). | Only scans files at this directory's top level (not subfolders). |

---
## What each parameter does
- **`path`**:
  Specifies which directory to scan for source files. The tool will look at all supported language files at the top level of this directory and extract definitions.

---
## Output Format
- Lists found definitions as:
  ```
  filepath:start_line--end_line | <definition snippet>
  ```
  - Multiple entries per file possible.
  - Shows both the location (lines) and the code snippet.

---
## Supported Usage Patterns
- Summarize architecture and important definitions in a project or module.
- Get an outline before making changes or adding features.
- Quickly locate where functions, classes, or interfaces are defined.

---
## Example Usage
**List code definitions in current directory:**
```
<list_code_definition_names>
  <path>.</path>
</list_code_definition_names>
```

**List code definitions in a subdirectory:**
```
<list_code_definition_names>
  <path>src/components</path>
</list_code_definition_names>
```

---

**Notes:**
- Only detects top-level (not nested) definitions.
- Ignores subdirectories; only the specified directory is scanned.
- Supports up to 50 files per call.
- Useful for JavaScript, TypeScript, Python, Rust, Go, C, C++, C#, Ruby, Java, PHP, Swift, Kotlin.

---
# insert_content Tool (Usage Details)
The `insert_content` tool adds new lines of content to an existing file, without changing or deleting any original lines. Ideal for inserting code, configuration, or data at precise locations.

---
## Parameters

| Name      | Required? | Description                                                              | Notes                                    |
|-----------|-----------|--------------------------------------------------------------------------|------------------------------------------|
| `path`    | Yes       | Relative path (from workspace root) of the file to insert into.           | File must already exist.                 |
| `line`    | Yes       | 1-based line number **before** which to insert. Use `0` to append at end. | Must be 0 or a positive integer.         |
| `content` | Yes       | Text/content block to insert.                                             | Any valid string, including multi-line.  |

---
## What each parameter does
- **`path`**: Specifies which file is to be edited.
- **`line`**: Indicates where (by line) new content should be inserted. If `0`, content is appended at the end.
- **`content`**: The new text/data block to insert.

---
## Supported Usage Patterns
- Insert new imports, function, or data at file start (`line: 1`)
- Insert at a specific location (`line: n`)
- Append content at file end (`line: 0`)

---
## Example Usage
**Insert imports at file start:**
```xml
<insert_content>
  <path>src/utils.ts</path>
  <line>1</line>
  <content>
// Add imports at start of file
import { sum } from './math';
import { parse } from 'date-fns';
  </content>
</insert_content>
```

**Append at end:**
```xml
<insert_content>
  <path>config/routes.yaml</path>
  <line>0</line>
  <content>
- path: /new-feature
  component: NewFeatureComponent
  auth_required: true
  </content>
</insert_content>
```

**Insert before line 50:**
```xml
<insert_content>
  <path>src/services/api.js</path>
  <line>50</line>
  <content>
async function fetchUserData(userId) {
  const response = await fetch(`/api/users/${userId}`);
  if (!response.ok) {
    throw new Error('Failed to fetch user data');
  }
  return response.json();
}
  </content>
</insert_content>
```

---

**Notes:**
- Does not delete or edit existing lines; for modifications, use `apply_diff` or `search_and_replace`.
- Target file must exist; tool does not create files.
- Always requires user to confirm and approve the insertion via diff view.


---


# 🛡️ LLM System Prompt – Frontend Code Guardrails

Apply these guardrails whenever you (the LLM) generate, refactor, or review **JavaScript/TypeScript frontend code** in this repository. Enforce them strictly; flag any violation and propose a compliant fix.

1. **Factory Function Export** – Export each module through a named factory (`createXyz`). Validate all dependencies at the top and expose a cleanup API. *No top‑level logic.*
2. **Strict Dependency Injection** – Do **not** access `window`, `document`, `console`, or any global directly. Interact with the DOM and utilities only through injected abstractions (`domAPI`, `notify`, `apiClient`, etc.).
3. **Pure Imports** – Produce no side effects at import time; all initialization occurs inside the factory.
4. **Centralized Event Handling** – Register listeners with `eventHandlers.trackListener(..., { context })` and remove them with `eventHandlers.cleanupListeners({ context })`.
5. **Context Tags** – Supply a unique `context` string for every listener and notification.
6. **Notifications via `notify`** – Replace `console` or `alert` calls with the injected `notify` utility (or `notify.withContext`). Maintain consistent metadata.
7. **Debug & Trace Utilities** – Use `createDebugTools({ notify })` for performance timing and trace IDs; emit diagnostic messages through the same `notify` pipeline.
8. **Context‑Rich Error Logging** – Capture errors with `errorReporter.capture(err, { module, method, … })`, never leaking tokens or PII.
9. **Sanitize All User HTML** – Always call `sanitizer.sanitize()` before inserting user content into the DOM.
10. **App Readiness** – Wait for `DependencySystem.waitFor([...])` *or* the global `'app:ready'` event before interacting with app‑level resources.
11. **Central `app.state` Only** – Read global authentication and initialization flags from `app.state`; do **not** mutate them directly.
12. **Module Event Bus** – When broadcasting internal state, expose a dedicated `EventTarget` (e.g., `AuthBus`) so other modules can subscribe without tight coupling.
13. **Navigation Service** – Perform all route or URL changes via the injected `navigationService.navigateTo(...)`.
14. **Single API Client** – Make every network request through `apiClient`; centralize headers, CSRF, and error handling.
15. **Notifier Factories** – Create module‑scoped notifiers with `notify.withContext({ module, context })`.
16. **Backend Event Logging** – Log critical client events with `backendLogger.log({ level, message, module, … })`.
17. **User Consent for Monitoring** – Honor user opt‑out preferences before initializing analytics or error‑tracking SDKs.

---

**Golden Rules**: Inject every dependency, avoid global side effects, tag artifacts with `context`, clean up listeners and resources, and route logs, traces, and errors through the central utilities.

## **Other Notable Smells to Avoid**


### ▪️ **Maintainability Smells**

* **Duplicated Code**

  * Multiple instances of similar logic scattered throughout codebase.
* **Long Functions**

  * Functions doing too much; harder to read, debug, or extend.
* **Magic Numbers and Strings**

  * Hardcoded values with unclear meanings or origins.
* **Excessive Nesting**

  * Deeply nested loops or conditions that make code unreadable.
* **Large Classes or Modules**

  * Modules that handle multiple concerns rather than adhering to Single Responsibility Principle.

---

### ▪️ **Design & Architectural Smells**

* **Global Variables**

  * Pollute the global namespace; increase coupling and unintended side-effects.
* **Strong Coupling (Tight Dependencies)**

  * Directly importing or referencing other modules directly instead of using dependency injection.
* **Primitive Obsession**

  * Overuse of primitive types (`string`, `number`) instead of proper objects or enums.
* **Feature Envy**

  * Functions or modules overly dependent on another module’s properties or methods.
* **Lack of Encapsulation**

  * Exposing too much internal logic, leading to fragile implementations.

---

### ▪️ **Performance & Optimization Smells**

* **Memory Leaks**

  * Not properly removing event listeners, timers, or intervals, causing leaks.
* **Repeated DOM Access**

  * Frequent unnecessary reads or updates to the DOM; causes slow UI.
* **Excessive Closures**

  * Creating unnecessary closures, causing memory overhead.
* **Inefficient Loops**

  * Repeated or redundant calculations within loops.

---

### ▪️ **Readability & Style Smells**

* **Deeply Nested Callbacks ("Callback Hell")**

  * Excessively nested callbacks making code hard to follow.
* **Overly Complex Expressions**

  * Chaining multiple ternaries, conditionals, or logical expressions together.
* **Commented-Out Code**

  * Indicates uncertainty, clutter, and outdated implementation.
* **Inconsistent Naming Conventions**

  * Mixed naming conventions (`camelCase`, `snake_case`, `PascalCase`).

---

### ▪️ **Async/Await Smells**

* **Unhandled Promise Rejections**

  * Missing proper error handling for promises.
* **Async Functions Without Await**

  * Declared as `async` but not leveraging `await`; causes confusion.
* **Improper Async Error Handling**

  * Not consistently using `try/catch` blocks around async calls.

---

### ▪️ **Testing & Error-Handling Smells**

* **Insufficient Test Coverage**

  * Lacking tests, especially for critical or complex functionality.
* **Silent Error Handling**

  * Empty catch blocks or ignoring errors completely.
* **Overly Broad Catch Statements**

  * Catching all exceptions (`catch(e)` without specifics) hides critical errors.

